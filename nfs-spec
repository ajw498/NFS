/*
	$Id$

	XDR Specification for the NFS V2 protocol.
	See RFC 1094 for more details.

	StrongEd$Mode=C
*/

#define NFS_RPC_PROGRAM 100003
#define NFS_RPC_VERSION 2

/* The maximum number of bytes of data in a READ or WRITE request. */
const MAXDATA = 8192;

/* The maximum number of bytes in a pathname argument. */
const MAXPATHLEN = 1024;

/* The maximum number of bytes in a file name argument. */
const MAXNAMLEN = 255;

/* The size in bytes of the opaque "cookie" passed by READDIR. */
const COOKIESIZE  = 4;

/* The size in bytes of the opaque file handle. */
const FHSIZE = 32;


enum nstat {
    NFS_OK = 0,
    NFSERR_PERM=1,

    NFSERR_NOENT=2,
    NFSERR_IO=5,
    NFSERR_NXIO=6,
    NFSERR_ACCES=13,
    NFSERR_EXIST=17,
    NFSERR_NODEV=19,
    NFSERR_NOTDIR=20,
    NFSERR_ISDIR=21,
    NFSERR_FBIG=27,
    NFSERR_NOSPC=28,
    NFSERR_ROFS=30,
    NFSERR_NAMETOOLONG=63,
    NFSERR_NOTEMPTY=66,
    NFSERR_DQUOT=69,
    NFSERR_STALE=70,
    NFSERR_WFLUSH=99
};

enum ftype {
    NFNON = 0,
    NFREG = 1,
    NFDIR = 2,
    NFBLK = 3,
    NFCHR = 4,
    NFLNK = 5
};

typedef opaque fhandle[FHSIZE];

struct ntimeval {
    unsigned int seconds;
    unsigned int useconds;
};

struct fattr {
    ftype        type;
    unsigned int mode;
    unsigned int nlink;
    unsigned int uid;
    unsigned int gid;
    unsigned int size;
    unsigned int blocksize;
    unsigned int rdev;
    unsigned int blocks;

    unsigned int fsid;
    unsigned int fileid;
    ntimeval      atime;
    ntimeval      mtime;
    ntimeval      ctime;
};

struct sattr {
    unsigned int mode;
    unsigned int uid;
    unsigned int gid;
    unsigned int size;
    ntimeval      atime;
    ntimeval      mtime;
};

typedef string filename<MAXNAMLEN>;

typedef string path<MAXPATHLEN>;

union attrstat switch (nstat status) {
case NFS_OK:

    fattr attributes;
default:
    void;
};

struct diropargs {
    fhandle  dir;
    filename name;
};

struct diropok {
    fhandle file;
    fattr   attributes;
};

union diropres switch (nstat status) {
case NFS_OK:
    diropok diropok;
default:
    void;
};

void NFSPROC3_NULL(void) = 0;

diropres NFSPROC_LOOKUP(diropargs) = 4;

typedef int nfscookie;
/* ? */

struct readdirargs {
        fhandle dir;
        nfscookie cookie;
        unsigned count;
};

/* Hacked the linked list a bit to make it simpler */
struct readdirok_entry_TRUE {
        unsigned fileid;
        filename name;
        nfscookie cookie;
};

union readdirok_entry switch (bool opted) {
case TRUE:
  readdirok_entry_TRUE u;
};

struct readdirok {
        /*entry *entries;*/
        bool eof;
};

struct readdirres {
	nstat status;
};

/*union readdirres switch (stat status) {
case NFS_OK:
       readdirok readdirok;
default:
        void;
};*/

readdirres NFSPROC_READDIR(readdirargs) = 16;

struct readargs {
        fhandle file;
        unsigned offset;
        unsigned count;
        unsigned totalcount;
};

union readres switch (nstat status) {
case NFS_OK:
        fattr attributes;
        opaque data<>;
default:
        void;
};

readres NFSPROC_READ(readargs) = 6;

struct writeargs {
        fhandle file;
        unsigned beginoffset;
        unsigned offset;
        unsigned totalcount;
        opaque data<>;
};

attrstat NFSPROC_WRITE(writeargs) = 8;

struct createargs {
        diropargs where;
        sattr attributes;
};

diropres NFSPROC_CREATE(createargs) = 9;

