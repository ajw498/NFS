<!-- $Id$ -->
<!-- $URL$ -->
<html>
<head>
  <title>Moonfish NFS server</title>
</head>

<body bgcolor="#ffffff" text="#000000">
<p align="center"><img src="title.png" alt="Moonfish" border=0>

<p>

<b>Moonfish</b>, <i>Drepane punctata</i><br>


<p>
<table bgcolor="#00449a" fgcolor="ffffff" width="99%"><tr><td>
<h2><font color="#ffffff">Contents</font></h2>
</td></tr></table>
<ul>
<li><a href="#license">License</a><br>
<li><a href="#requirements">Requirements</a><br>
<li><a href="#servers">Servers</a><br>
<li><a href="#setup">Setting up a Mount</a><br>
<li><a href="#options">Options</a><br>
<li><a href="#performance">Improving Performance</a><br>
<li><a href="#reportingbugs">Reporting Bugs</a><br>
<li><a href="#knownbugs">Known Issues</a><br>
<li><a href="#recompiling">Recompiling</a><br>
</ul>


<table bgcolor="#00449a" fgcolor="ffffff" width="99%"><tr><td>
<h2><font color="#ffffff"><a name="license">License</a></font></h2>
</td></tr></table>

<p>
Moonfish is copyright &copy; 2006 <a href="mailto:alex@alexwaugh.com">Alex Waugh</a>
<p>
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
<p>
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
<p>
You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
<p>

<table bgcolor="#00449a" fgcolor="ffffff" width="99%"><tr><td>
<h2><font color="#ffffff"><a name="introduction">Introduction</a></font></h2>
</td></tr></table>
<p>
Moonfish is an NFS server, that can be used to share files to another computer. It has been tested with clients including Linux 2.4 and Sunfish on RISC OS, but should work with any suitable NFS client on any platform.
The server supports version 2 or version 3 of the NFS protocol, version 1 or 3 of the Mount protocol, and version 2 of the portmapper protocol. Both UDP and TCP connections are supported.
<p>
It runs as a module in the background, and so can continue to serve files even when the machine is single tasking.
<p>
Moonfish should run on any version of RISC OS from 3.11 onwards, although it has only been tested on RISC OS 4 and RISC OS 5. It is 26/32bit neutral, and requires a 32bit Shared C Library that includes C99 features.
<p>

Any updates will be available from <a href="http://www.alexwaugh.com/">http://www.alexwaugh.com/</a>

<p>
<table bgcolor="#00449a" fgcolor="ffffff" width="99%"><tr><td>
<h2><font color="#ffffff"><a name="setup">Setting up a mount</a></font></h2>
</td></tr></table>
<p>
Sunfish is implemented as an image filing system. You can either write a mount file by hand, or use the frontend to create one.
<p>
To use the frontend, run !Sunfish which will put an icon on the lefthand side of the iconbar. Select <code>New mount...</code> from the menu then fill in appropriate values for all the options. The options correspond with those described below, and the default values in the filenames, connection and ports sub-windows should not need altering for most simple connections. The mount leafname option is used to give a name to refer to the mount file. When you click on <code>Create</code> then a mount file with the specified options will be created, and a new icon will be added to the iconbar for that mount.
<p>
To manually write a mount file, use your favorite<!-- <message type="subliminal">StrongED</message> --> text editor to create a file with the appropriate options as described below. Save this, then set it's filetype to Sunfish (&1b6). Then double click on the mount file you have just created and the server will be mounted and you can navigate the filesystem as normal.
<p>
Due to the way image filing systems work, you may not be able to edit the mount file once it has been mounted and while Sunfish is still running. There are two solutions - either set the filetype of the mount file to Text, edit it, then set it back to Sunfish, or *RMKill Sunfish before editing the file.
<p>
You may also have to ensure that the connection is not blocked by a firewall. The default configuration on some RedHat systems is known to block NFS traffic.

<h3>Example mount files</h3>
<p>
This is a very simple mount file. It will use pcnfsd to map the username and password onto a uid and gid.
<pre>
Protocol: NFS2
Server: mint.cp15.org
Export: /home/ajw498
Username: ajw498
Password: fiddlesticks
</pre>
<p>
The same as above, but specifying the uid and gid explicitly. pcnfsd is not required in this case, and there is no need for the password to be stored in the file either.
<pre>
Protocol: NFS2
Server: mint.cp15.org
Export: /home/ajw498
UID: 1001
GID: 50
</pre>
<p>
A more complex example.
<pre>
Protocol: NFS3
Server: mint.cp15.org
Transport: tcp
Export: /tmp
UID: 1002
GID: 51
GIDs: 52 53 105
umask: 066
MachineName: caramel
ShowHidden: 0
Timeout: 5
DefaultFiletype: FFF
AddExt: 2
MaxDataBuffer: 32768
Pipelining: 1
</pre>

<h3>Filenames</h3>
Filenames on a unix machine may contain characters that are illegal in RISC OS filenames. In order to allow access to such files, any illegal characters are changed into escape sequences of <code>?xx</code> where xx is the hexadecimal value of the character. Spaces are mapped onto hard spaces, dots map to slashes and vice versa, and other characters are unchanged.
<p>
Unlike most other RISC OS filing systems, filenames may be case sensitive (depending on the casesensitive option). However, it is not recommended to use filenames that differ only in their case, as some programs or RISC OS may not distinguish between them correctly.
<p>
<table bgcolor="#00449a" fgcolor="ffffff" width="99%"><tr><td>
<h2><font color="#ffffff"><a name="options">Options</a></font></h2>
</td></tr></table>
<p>
Any line beginning with a # is treated as a comment. 

<h3>Mandatory options</h3>
These options must be set for a working export to be set up.
<p>
<h4>Directory</h4>
Specifies the directory to export. This can be any directory on a local filing system, including a root directory. You can drag a directory from the filer onto this field in the GUI to fill in the icon.
<p>
<h4>Export</h4>
This is the name to export the directory as. It can be the same as the leafname of the directory, or it can be different. Some clients may expect it to be in the format of a Unix path, for example <code>/home</code>.
<p>
<h4>Allow connections from</h4>
This allows you to limit the client machines that are allowed to access the export. It can be specified as a hostname or IP address of a single machine, an IP address and netmask to allow a range of IP addresses (e.g. 192.168.0.0/24 to allow and address in the range 192.168.0.0 to 192.168.0.255), or it can be * to allow access from any address. If allowing any address to access the server, it is strongly recommeded that you use some sort of firewall to prevent access from unwanted machines.
<p>
<h3>Optional options</h3>
These options can be specified if needed, but if they are not then default values will be used. For many cases the defaults will be sufficient.
<p>
<h4>UID</h4>
The UID to report all files and directories belong to. If left blank, the UID used will be whatever the client reports its UID as.
<p>
<h4>GID</h4>
The GID to report all files and directories belong to. If left blank, the GID used will be whatever the client reports its primary GID as.
<p>
<h4>UDP transfer size</h4>
The maximum number of bytes to use for the data buffer of a read or write request on UDP transfers. A bigger buffer will generally be faster than a smaller one, but some network cards (In particular, the Castle 100BaseT podule) cannot handle larger packets when using UDP. The maximum value is 8192 bytes, and it is recommeded that you set it to this if your network card can handle it (You will probably get timeout errors when reading a large file if it is too big). If omitted, it defaults to 4096 bytes.
<p>
<h4>Read only</h4>
If set the export will be marked as read only, and any writes will be prevented.
<p>
<h4>Fake directory timestamps</h4>
On Unix like filesystems, the timestamp of a directory gets updated whenever the contents of a directory are altered, e.g. a new file is added to the directory. Some clients will cache the contents of directories to improve performance, and use the timestamp of the directory to determine whether the cache is out of date or not. However RISC OS does not update the timpstamp of the directory when you add or delete a file from it, and so such a caching system will not update its cache correctly. If this option is set, the timestamp of all directories are reported as the current time, so that any cache will always get updated (although this negates some of the benefit of caching).
<p>
<h4>Treat image filing systems as directories</h4>
By default, image files (e.g. zip files when SparkFS is loaded) will be reported as files. If this option is set then they will be treated as directories, and so the client will not realise that they are actually files, and can manipulate the contents.
<p>
<h4>umask</h4>
The umask to use, specified in octal. All operations that return a file's attributes will have the Unix mode bits modified according to the umask. If not specified, it defaults to 000, and the mode bits are not modified.
<p>
<h4>unumask</h4>
RISC OS does not have any concept like a umask - the default attributes of a file are decided by the application that creates the file. Usually the default chosen is private read/write set and public read/write clear, although sometimes private read/write is not set either, which doesn't have any effect on RISC OS applications accessing the files, but can prevent Unix applications from accessing them. The unumask allows you to force particular unix mode bits to be set, and is specified in octal in the same format as the umask. If not specified, it defaults to 0.
<p>
The RISC OS attributes are first converted to unix mode bits, with the private attributes mapping to user permissions, and the public attributes mapping to the group and others permissions (if a public attribute is set then both the corresponding group and others permission bit will be set). If the object is a directory then execute permissions will be set if the corresponding read permission is set. This value is then ORed with the unumask, and then ANDed with the inverse of the umask to give the final unix mode bits.
<p>
<h4>DefaultFiletype</h4>
The hexadecimal filetype to give a file if it doesn't have an ,xyz filetype extension or a . extension that matches a mimemap entry. If not specified then it defaults to FFF.
<p>
<h4>Add extension</h4>
Controls adding of a ,xyz filetype extension. When 0, no ,xyz extensions are added, and all files get the default filetype. When 1, a ,xyz extension is only added when necessary. If the file has a . extension that matches a mimemap entry then no extension is added. When 2, a ,xyz extension is always added. If not specified, the default is 1.
<p>

<table bgcolor="#00449a" fgcolor="ffffff" width="99%"><tr><td>
<h2><font color="#ffffff"><a name="performance">Improving Performance</a></font></h2>
</td></tr></table>
<p>
There are four options that are likely to have an effect on performance: the protocol, the transport, the MaxDataBuffer option and the Pipelining option.
<p>
NFS3 should be faster than NFS2, because it is more efficient when listing directory contents, and allows larger data buffers.
<p>
Using TCP as the transport may give better results than UDP in most circumstances.
<p>
Normally, the bigger the data buffer the better, however some network cards (notably the Castle 100bT podule) cannot cope with large packet sizes when using UDP. I suggest you try setting it to the maximum, and if you start getting timeout errors when transferring files then reduce it.
<p>
The pipelining option (which is disabled by default) allows file read and write requests to be pipelined which can give around a 20% increase in speed. However, with some servers or network setups it could make things slower. If, for example, your server is running on a 100bT segment while the client is the other side of a switch on a 10bT segment then it is likely to make things worse on a UDP connection, but if the server and client are of comparable speeds on the same segment then it may make things faster.
<p>
The server can also have a influence on the speed.
<p>
I have found the fastest settings on an Iyonix with a 1000bT connection to be NFS3 over TCP, with a data buffer of 32768 and pipelining turned on.
<p>
The following table shows the maximum speeds I have obtained with various settings, and a comparison with LanMan98 and LanManFS. If you are seeing significantly slower results then it may be worth experimenting with the above options. All the tests were copying a 125MB file using the filer with the faster option set.
<p>
<table border="1">
<tr>
<th></th><th colspan="2">Iyonix 1000bT</th><th colspan="2">Iyonix 100bT</th><th colspan="2">SA RPC, Simtec 100bT</th>
</tr>
<tr>
<th></th><th>Read</th><th>Write</th><th>Read</th><th>Write</th><th>Read</th><th>Write</th>
</tr>
<tr>
<td>Sunfish NFS2 UDP</td><td>9.2MB/s</td><td>10.3MB/s</td><td>7.3MB/s</td><td>8.8MB/s</td><td>1.2MB/s</td><td>1.2MB/s</td>
</tr>
<tr>
<td>Sunfish NFS3 TCP</td><td>9.5MB/s</td><td>11.2MB/s</td><td>5.9MB/s</td><td>7.3MB/s</td><td>1.2MB/s</td><td>1.1MB/s</td>
</tr>
<tr>
<td>LanMan98</td><td>8.8MB/s</td><td>2.0MB/s</td><td>7.3MB/s</td><td>4.3MB/s</td><td>1.3MB/s</td><td>0.78MB/s</td>
</tr>
<tr>
<td>LanManFS</td><td>2.9MB/s</td><td>5.7MB/s</td><td>2.8MB/s</td><td>5.9MB/s</td><td></td><td></td>
</tr>
</table>
<p>

<table bgcolor="#00449a" fgcolor="ffffff" width="99%"><tr><td>
<h2><font color="#ffffff"><a name="reportingbugs">Reporting Bugs</a></font></h2>
</td></tr></table>
<p>
If you discover a bug, please report it to <a href="mailto:alex@alexwaugh.com">me</a>, or better still fix it yourself and send me a patch. When reporting a bug, first make sure <a href="http://www.compton.nu/syslog.html">SysLog</a> is loaded, and check the Moonfish log if it exists for any error messages. If you have access to a machine that can run a packet sniffer such as ethereal then it would be very useful to use that to save a dump of the network traffic along with the syslog file. Also, please provide a description of the problem and exactly what operation you were doing to trigger the bug, and details of what OS and NFS version the client is running would be helpful, and the version of the Moonfish module and RISC OS version.
<p>
<table bgcolor="#00449a" fgcolor="ffffff" width="99%"><tr><td>
<h2><font color="#ffffff"><a name="knownbugs">Known Issues</a></font></h2>
</td></tr></table>
<p>
Each file should have a unique ID associated with it (the inode on a Unix system), but RISC OS does not provide a method for generating this, therefore it is calculated as a hash of the filename. While this will be unique in most cases, it is possible for two files to end up with the same ID. This could be an issue if a client relies on the uniqueness of the ID, but it has not yet been observed as a problem in practice.
<p>
NFS refers to files by an NFS filehandle, and Moonfish must be able to map an NFS filehandle onto a RISC OS filename. For filenames that are less than 64 characters (or 32 characters in NFS2) this is easy as the filename can be stored fully in the filehandle. However for filenames longer than this, Moonfish must maintain a cache of the mappings from filehandle to filename. Therefore if you access lots of different files with long filenames then this cache will grow and use more memory. The format of the cache imposes a limit on the number of directory levels supported (30 for NFS2, 62 for NFS3) but this is unlikely to be an issue.
<p>
NFS filehandles are supposed to be persistant, so if the server is restarted or rebooted the filehandle should remain valid and point to the same file. However because Moonfish maintains the cache to map filehandles to filenames, this cache is lost when Moonfish exits, and so the mapping is no longer valid. Most clients will reread the filehandle if it becomes stale, and so can cope with this situation.
<p>
Hard links, symbolic links, devices and other non regular files are not supported, as they don't map to RISC OS functionality.
<p>
<table bgcolor="#00449a" fgcolor="ffffff" width="99%"><tr><td>
<h2><font color="#ffffff"><a name="recompiling">Recompiling</a></font></h2>
</td></tr></table>
<p>
Full source code is provided. To recompile the module, you will need Norcroft v5.53 or later, cmhg 5.42 or later, TCPIPLibs, and Perl. Earlier 26bit versions of Norcroft will not work because the code makes use of 64bit integers and some C99 functions. It can take a long time (almost 10 minutes) to compile nfs3-calls.c. This time can be shortened by disabling cse optimisations with the -zpz0 flag. Later versions of Norcroft may have improved this.
<p>
For some unknown reason, if you use amu then it will give an error <code>AMU: Don't know how to make 'o.pcnfsd-calls'</code> after generating pcnfsd-calls.c, but if you rerun amu then it will work. GNU make does not give this problem.

</body>
</html>
