#!/usr/bin/perl -w
#use strict;

my @states;
my $state = "none";
my @names;
my $name = "";
my %types;
my $nextunnamed = 1;
my @unnamed;

open(PROCS,">processstructs.h") or die $^E;
open(UNIONS,">processunions.h") or die $^E;
open(STRUCTS,">nfsstructs.h") or die $^E;
open(CALLS,">nfsrpccalls.c") or die $^E;
open(CALLSH,">nfsrpccalls.h") or die $^E;

my $header = "/* Automatically generated */\n\n";

print PROCS   $header;
print UNIONS  $header;
print STRUCTS $header;
print CALLS   $header;
print CALLS   "#include nfsrpccalls.h\n\n";
print CALLS   "#include rpc.h\n\n";
print CALLSH  $header;
print CALLSH  "#include nfsstructs.h\n";
print CALLSH  "#include processstructs.h\n";
print CALLSH  "#include processunions.h\n\n";
$types{"unsigned int"} = "int";

while (<>) {
  #print "$state - $_";
  if ($state eq "struct" or $state eq "union") {
    if (/\}\;/) {
      if ($state eq "union") {
        print STRUCTS "} u;\n};\n";
        print UNIONS "}} while (0);\n\n";
      } else {
        print STRUCTS;
      }
      print PROCS "} while (0);\n\n";
      $state = "none";
    } elsif (/\}.+\;/) {
      die "struct/union instance: $_";
    } elsif (/case (\w*)\:/) {
      print UNIONS "case $1:\\\n";
      print UNIONS "process_union_body_${name}_$1(input,structbase.u);\\\n";
      print PROCS "} while (0);\n";
      print PROCS "#define process_union_body_${name}_$1(input,structbase) do {\\\n";

    } elsif (/(.*)opaque (\w*)\<(\w*)\>\;/) {
      print STRUCTS "${1}struct opaque $2;\n";
      print STRUCTS "#define OPAQUE_${name}_${2}_MAX $3\n";
      print PROCS "process_opaque(input,structbase.$2,$3);\\\n";
    } elsif (/(\s*)(.*)\s+(\w+)\;/) {
      my $type = $types{$2};
      die "Unknown type $2\n" unless defined $type;
      if (($type eq "struct") || ($type eq "union")) {
        print STRUCTS "${1}struct $2 $3;\n";
        print PROCS "process_${type}_$3(input,structbase.$3);\\\n";
      } else {
        print STRUCTS "${1}$2 $3;\n";
        print PROCS "process_$type(input,structbase.$3);\\\n";
      }
    } elsif (/\/\*.*\*\//) {
      print STRUCTS;
    } else {
      die "Unknown struct field\n";
    }
  } elsif ($state eq "enum") {
    print STRUCTS;
    $state = "none" if (/\}\;/);
  } elsif ($state eq "comment") {
    print STRUCTS;
    $state = "none" if (/\*\//);
  } elsif ($state eq "none") {

    if (/enum *(\w*)/) {
      print STRUCTS;
      $name = $1;
      $types{$name} = $state = "enum";
    } elsif (/struct *(\w*) /) {
      print STRUCTS;
      $name = $1;
      $types{$name} = $state = "struct";
      print PROCS "#define process_struct_${name}(input,structbase) do {\\\n";
    } elsif (/union *(\w*) *switch *\( *(\w*) *(\w*)\)/) {
      $name = $1;
      $types{$name} = $state = "union";
      print STRUCTS "struct ${name} {\n";
      print STRUCTS "$2 $3;\n";
      print STRUCTS "union {\n";
      print PROCS "#define process_union_${name}_dummy do {\\\n";
      print UNIONS "#define process_union_${name}(input,structbase) do {\\\n";
      print UNIONS "process_int(input,structbase.$3);\\\n";
      print UNIONS "switch (structbase.$3) {\\\n";
    } elsif (/\#define/) {
      print STRUCTS;
    } elsif (/typedef (.*) (\S+)\;/) {
      # doesnt yet cope with unsigned foo or string or opaque
      print STRUCTS;
      $types{$2} = $1;
    } elsif (/(\w*) (\w*)\((\w*)\) = (\w*)\;/) {
      print CALLSH "\nint $2(struct $3 *args, struct $1 *res, struct opaque_auth *cred);\n";
      print CALLS  "\nint $2(struct $3 *args, struct $1 *res, struct opaque_auth *cred)\n";
      print CALLS "{\n";
      print CALLS "\tprepare_call($4);\n";
      print CALLS "\tprocess_struct_$3(OUTPUT,(*args));\n";
      # Read results
      print CALLS "\tdo_call();\n";
      print CALLS "\tprocess_struct_$1(INPUT,(*res));\n";
      print CALLS "}\n";
    } elsif (/\/\*.*\*\//) {
      print STRUCTS;
    } elsif (/\/\*/) {
      print STRUCTS;
      $state = "comment";
    } elsif (/^\s*$/) {
      print STRUCTS;
    } else {
      die "Unknown input\n";
    }
  } else {
    die "Unknown state\n";
  }
}

#  } elsif (/(.*)opaque *(\w*)\[(\d*)\]/) {
#    print STRUCTS "#define ".$name."_"."$2"."_max $3\n";
#    print STRUCTS "$1char $2[$3];\n";
#  } elsif (/(.*)opaque *(\w*)\<(\d*)\>/) {
#    print STRUCTS "#define $name"."_"."$2"."_max $3\n";
#    print STRUCTS "$1int $2_size;\n";
#    print STRUCTS "$1char *$2;\n";
#  } elsif (/case *(\w*)\:/) {
#    ##
#  } elsif (/(.*)union *switch *\( *(\w*) *(\w*)\)/) {
#    die "Unnamed union\n";
